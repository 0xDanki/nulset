# NulSet Onchain Architecture

## Current State (Phase 1-2): 100% Offchain âŒ

### What's Currently Offchain
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Everything runs in browser/locally:    â”‚
â”‚                                          â”‚
â”‚  âœ“ Tree building (JavaScript)           â”‚
â”‚  âœ“ Merkle root computation               â”‚
â”‚  âœ“ Witness generation                    â”‚
â”‚  âœ“ Proof generation (WASM)               â”‚
â”‚  âœ“ Proof verification (snarkjs)          â”‚
â”‚  âœ“ Ban list storage (JSON files)        â”‚
â”‚  âœ“ No persistence                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Limitations:
- âŒ No shared state between users
- âŒ Admin must distribute root manually
- âŒ No immutable audit trail
- âŒ Ban list can be modified locally
- âŒ No trustless verification
```

### Why It's Still Valuable (Offchain)
- âœ… Fast development/iteration
- âœ… Zero gas costs for testing
- âœ… Works immediately (no deployment)
- âœ… Perfect for hackathon demo
- âœ… Proves the cryptography works

---

## Future State (Phase 3+): Hybrid Architecture ğŸ¯

### What Should Go Onchain

#### 1. Merkle Root Registry (Critical)
```solidity
// Smart contract on Ethereum/Base/etc
contract NulSetRegistry {
    // Platform => Current Merkle Root
    mapping(address => bytes32) public platformRoots;
    
    // Platform => Root => Timestamp
    mapping(address => mapping(bytes32 => uint256)) public rootHistory;
    
    // Update root (only platform admin)
    function updateRoot(bytes32 newRoot) external {
        require(msg.sender == platformAdmin[msg.sender]);
        platformRoots[msg.sender] = newRoot;
        rootHistory[msg.sender][newRoot] = block.timestamp;
        emit RootUpdated(msg.sender, newRoot, block.timestamp);
    }
    
    // Anyone can verify against current root
    function verifyProof(
        address platform,
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view returns (bool) {
        bytes32 expectedRoot = platformRoots[platform];
        require(publicInputs[0] == expectedRoot, "Root mismatch");
        return verifier.verify(proof, publicInputs);
    }
}
```

**Why onchain:**
- âœ… Immutable root history
- âœ… Trustless verification
- âœ… Cross-platform consistency
- âœ… Audit trail
- âœ… No single point of failure

#### 2. Proof Verification (Gas Optimization)
```solidity
// Groth16 verifier (generated by snarkjs)
contract Groth16Verifier {
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[1] memory input  // Public root
    ) public view returns (bool) {
        // Pairing check for Groth16
        // ~300k gas per verification
    }
}
```

**Why onchain:**
- âœ… Verifiable by smart contracts
- âœ… Can gate protocol actions
- âœ… No trust in platform
- âœ… Censorship resistant

#### 3. Platform Registry (Optional)
```solidity
contract PlatformRegistry {
    struct Platform {
        address admin;
        bytes32 currentRoot;
        string name;
        bool active;
    }
    
    mapping(address => Platform) public platforms;
    
    function registerPlatform(string memory name) external {
        platforms[msg.sender] = Platform({
            admin: msg.sender,
            currentRoot: bytes32(0),
            name: name,
            active: true
        });
    }
}
```

**Why onchain:**
- âœ… Discover all platforms using NulSet
- âœ… Multi-platform support
- âœ… Reputation system

---

## Proposed Hybrid Architecture

### Offchain (Browser/Client)
```
User's Browser:
â”œâ”€â”€ TLSNotary Extension
â”‚   â””â”€â”€ Twitter verification
â”œâ”€â”€ NulSet Frontend
â”‚   â”œâ”€â”€ Witness generation (local)
â”‚   â””â”€â”€ Proof generation (WASM)
â””â”€â”€ Web3 Wallet
    â””â”€â”€ Submits proof onchain
```

### Onchain (Smart Contracts)
```
Blockchain:
â”œâ”€â”€ NulSetRegistry
â”‚   â”œâ”€â”€ Store Merkle roots
â”‚   â””â”€â”€ Root update events
â”œâ”€â”€ Groth16Verifier
â”‚   â””â”€â”€ Verify ZK proofs
â”œâ”€â”€ PlatformRegistry (optional)
â”‚   â””â”€â”€ Register platforms
â””â”€â”€ AccessGate (per platform)
    â””â”€â”€ Gate actions with proofs
```

### Data Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Admin    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚ 1. Upload banned Twitter IDs
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Build Tree     â”‚ (Offchain)
â”‚ Compute Root   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ 2. Submit root to chain
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NulSetRegistry.sol â”‚ (Onchain)
â”‚ platformRoots[P]   â”‚
â”‚ = 0x1a2b3c...      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚ 3. User visits platform
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User generates     â”‚ (Offchain)
â”‚ - Twitter proof    â”‚
â”‚ - Witness          â”‚
â”‚ - NulSet proof     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ 4. Submit proof to chain
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Platform dApp      â”‚ (Onchain)
â”‚ verifyProof()      â”‚
â”‚ - Check root       â”‚
â”‚ - Verify ZK proof  â”‚
â”‚ - Grant access     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Implementation Plan

### Phase 3a: Basic Onchain Registry (1-2 days)

**Deploy:**
```bash
# 1. Generate Solidity verifier
cd circuits/compiled
snarkjs zkey export solidityverifier verify_nonmembership_0000.zkey Verifier.sol

# 2. Deploy contracts
forge create NulSetRegistry --rpc-url $BASE_RPC --private-key $PRIVATE_KEY
forge create Groth16Verifier --rpc-url $BASE_RPC --private-key $PRIVATE_KEY
```

**Update frontend:**
```typescript
// web/src/lib/onchain/registry.ts
import { ethers } from 'ethers'

export async function submitRootOnchain(root: string) {
  const registry = new ethers.Contract(REGISTRY_ADDRESS, ABI, signer)
  const tx = await registry.updateRoot(root)
  await tx.wait()
}

export async function verifyProofOnchain(proof: NulSetProof) {
  const verifier = new ethers.Contract(VERIFIER_ADDRESS, ABI, provider)
  return await verifier.verifyProof(proof.proof, proof.publicSignals)
}
```

**Estimated gas costs:**
- Deploy Registry: ~500k gas (~$5-50 depending on chain)
- Deploy Verifier: ~3M gas (~$30-300)
- Update root: ~50k gas (~$0.50-5)
- Verify proof: ~300k gas (~$3-30)

### Phase 3b: Multi-Platform Support (2-3 days)

**Features:**
- Platform registry contract
- Multiple ban lists per platform
- Root versioning
- Event emissions for indexing

### Phase 3c: Optimizations (3-5 days)

**Gas optimizations:**
- Batch root updates
- Merkle root aggregation
- Recursive proof composition
- Layer 2 deployment (Base, Arbitrum)

**Frontend integration:**
- Wallet connection (RainbowKit/Wagmi)
- Transaction signing
- Event listening
- Loading states

---

## Chain Recommendations

### Option 1: Base (Recommended for Hackathon)
- âœ… Low gas costs
- âœ… Fast finality
- âœ… Ethereum ecosystem
- âœ… Good for consumer apps
- âœ… Coinbase backing

**Deployment:**
```bash
# Base Sepolia (testnet)
forge create NulSetRegistry --rpc-url https://sepolia.base.org --private-key $PK

# Base Mainnet
forge create NulSetRegistry --rpc-url https://mainnet.base.org --private-key $PK
```

### Option 2: Ethereum L1
- âœ… Maximum security
- âœ… Most decentralized
- âŒ High gas costs ($10-100 per proof)
- âŒ Slower

### Option 3: Arbitrum/Optimism
- âœ… Low gas costs
- âœ… Ethereum security
- âœ… Fast
- âœ… Good tooling

### Option 4: Polygon
- âœ… Very low gas
- âœ… Fast
- âœ… Established ecosystem

---

## What to Build First (Recommendation)

### Minimum Viable Onchain (1 day)
```
1. Deploy Groth16Verifier (snarkjs generated)
2. Deploy simple RootRegistry
3. Add "Submit to Chain" button in Admin panel
4. Add "Verify Onchain" option in Platform Demo
5. Show transaction links
```

**This proves:**
- âœ… ZK proofs work onchain
- âœ… Gas costs are reasonable
- âœ… Integration is possible
- âœ… Foundation for Phase 4+

### Full Production (1-2 weeks)
```
1. Multi-platform registry
2. Optimized verifier
3. Event indexing (The Graph)
4. Root history viewer
5. Admin dashboard
6. Analytics
```

---

## Current vs Future Comparison

| Feature | Current (Phase 2) | With Onchain (Phase 3+) |
|---------|-------------------|-------------------------|
| **Root storage** | Local JSON | Smart contract |
| **Verification** | Client-side | Onchain + client |
| **Trust model** | Trust platform | Trustless |
| **Persistence** | None | Permanent |
| **Multi-platform** | Manual | Automatic |
| **Audit trail** | None | Immutable |
| **Gas costs** | $0 | $1-10 per action |
| **Censorship resistance** | Low | High |
| **Setup complexity** | Easy | Medium |

---

## Decision: Do We Need Onchain?

### âœ… Yes, if:
- Building production system
- Need trustless verification
- Multi-platform deployment
- Want immutable audit trail
- Protocol integration (DeFi, DAOs)

### âŒ No, if:
- Just a hackathon demo
- Tight timeline (< 3 days)
- Want zero gas costs
- Testing/iterating rapidly
- Single platform use case

### ğŸ¯ Recommendation for YOU:
**Phase 2 (Offchain) is perfect for hackathon demo.**
**Add Phase 3 (Onchain) if you have extra time or want production deployment.**

---

## Next Steps

**Option A: Stay Offchain (Fastest)**
- âœ… Demo works now
- âœ… Focus on UX polish
- âœ… Add more test cases
- âœ… Prepare presentation

**Option B: Add Basic Onchain (1 day)**
- Deploy verifier to Base Sepolia
- Add "Verify Onchain" button
- Show transaction on Basescan
- Prove it works end-to-end

**Option C: Full Onchain (3-5 days)**
- Build complete registry
- Multi-platform support
- Event indexing
- Production-ready contracts

**What would you like to do?**
